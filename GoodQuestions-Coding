1. Given a string S and a string T, find the minimum window in S which will contain all the characters in T in linear time complexity.
Note that when the count of a character C in T is N, then the count of C in minimum window in S should be at least N.

Example :

S = "ADOBECODEBANC"
T = "ABC"
Minimum window is "BANC"

 Note:
If there is no such window in S that covers all characters in T, return the empty string ''.
If there are multiple such windows, return the first occurring minimum window ( with minimum start index ).


2. Given an arbitrary unweighted rooted tree which consists of N nodes.
The goal of the problem is to find largest distance between two nodes in a tree.
Distance between two nodes is a number of edges on a path between the nodes (there will be a unique path between any pair of nodes since it is a tree).
The nodes will be numbered 0 through N - 1.
The tree is given as an array A, there is an edge between nodes A[i] and i (0 <= i < N). Exactly one of the i's will have A[i] equal to -1, it will be root node.

Problem Constraints
1 <= N <= 40000

Input Format
First and only argument is an integer array A of size N.

Output Format
Return a single integer denoting the largest distance between two nodes in a tree.

Example Input
Input 1:
A = [-1, 0, 0, 0, 3]
Example Output
Output 1:
3

Example Explanation
Explanation 1:
node 0 is the root and the whole tree looks like this: 
          0
       /  |  \
      1   2   3
               \
                4

 One of the longest path is 1 -> 0 -> 3 -> 4 and its length is 3, thus the answer is 3.
 
 
You are given a read only array of n integers from 1 to n.
Each integer appears exactly once except A which appears twice and B which is missing.
Return A and B.

Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Note that in your output A should precede B.

Example:
Input:[3 1 2 5 3] 
Output:[3, 4] 
A = 3, B = 4

vector<int> Solution::repeatedNumber(const vector<int> &A) {
    int Axor = 0;
    int sum = 0;
    int Txor = 0, i = 1;
    int len = A.size();
    
    for (int i = 0; i < len; ++i)
    {
        Txor = Txor ^ (i+1);
        Axor = Axor ^ A[i];
        sum += A[i];
    }
    
    int actualSum = (len * (len + 1)) / 2;
    int diff = sum - actualSum;
    int repeat;
    
    for (int i = 1; i <= len; ++i)
    {
        repeat = diff + i;
        if (repeat < 1 || repeat > len) continue;
        
        if ((Axor ^ i ^ repeat) == Txor) return { repeat, i};
    }
    
    return {0,0};
}


N light bulbs are connected by a wire.
Each bulb has a switch associated with it, however due to faulty wiring, a switch also changes the state of all the bulbs to the right of current bulb.
Given an initial state of all bulbs, find the minimum number of switches you have to press to turn on all the bulbs.
You can press the same switch multiple times.
Note : 0 represents the bulb is off and 1 represents the bulb is on.
Input Format:
The first and the only argument contains an integer array A, of size N.
Output Format:
Return an integer representing the minimum number of switches required.

Constraints:
1 <= N <= 5e5
0 <= A[i] <= 1

Example:

Input 1:
    A = [1]

Output 1:
    0

Explanation 1:
    There is no need to turn any switches as all the bulbs are already on.

Input 2: 
    A = [0 1 0 1]

Output 2:
    4

Explanation 2:
	press switch 0 : [1 0 1 0]
	press switch 1 : [1 1 0 1]
	press switch 2 : [1 1 1 0]
	press switch 3 : [1 1 1 1]
int Solution::bulbs(vector<int> &A) {
    int xr = 0, cnt = 0, i, j; 
    for(i = 0; i < A.size(); ++i){
        if((A[i] ^ xr) == 0) xr ^= 1, cnt++;
    }
    return cnt;
}
